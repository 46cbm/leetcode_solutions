# 例1_畅通工程

**题目描述：**

```
某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。“畅通工程”的目标是使全省任何两个城镇间都可以实现连通（不一定是直接连通，间接连通也可以）。问最少还要修多少道路？
```

**输入：**

```
测试输入包含多个实例。每个实例第一行给出两个正整数，分别是城镇数目N(<1000)和道路数目M：随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连接的两个城镇的编号。为简单起见，城镇从1到N编号。N为0时，表示输入结束。
```

**输出：**

```
对每个实例，在1行里输出最少还要建多少条道路。
```

**输入样例：**

```
4 2
1 3
4 3
3 3
1 2
1 3
2 3
5 2
1 2
3 5
999 0
0
```

**输出样例：**

```
1
0 
2
998
```



**思路：**

```
统计连通分量个数，要建的最少道路的数目即是连通分量的个数-1。
统计连通分量的个数可用并查集完成。
```



**代码：**

```c++
#include<stdio.h>
using namespace std;
#define N 100

int Tree[N];
int FindRoot(int x){
	if(Tree[x] == -1) return x;
	else{
		int tmp = FindRoot(Tree[x]);
		Tree[x] = tmp;			//路径压缩
		return tmp; 
	}
}

int main(){
	int n, m;
	while(scanf("%d", &n) != EOF && n != 0){
		scanf("%d", &m);
		for(int i = 1; i <= n; i++)		//全部初始化为-1，都不连通 
			Tree[i] = -1;
		while(m--){
			int a, b;
			scanf("%d%d", &a, &b);
			a = FindRoot(a);
			b = FindRoot(b);
			if(a != b) Tree[a] = b;		//合并这两个集合，因为已经有路 
		} 
		int ans = 0;
		for(int i = 1; i <= n; i++)
			if(Tree[i] == -1) 
				ans++;
		printf("%d\n", ans-1);
	}
}
```

