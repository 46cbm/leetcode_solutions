# 例6_最短路径问题

**题目描述：**

```
给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s和终点t，要求输出起吊到终点的最短距离及其花费。如果最短距离有多条路线，则输出花费最少的。
```

**输入：**

```
输入n，m，点的编号是1~n，然后是m行，每行4个数a、b、d、p，表示a、b之间有一条边，且其长度是d，花费是p。最后一行是两个数s、t，分别是起点和终点。
n、m为0时输入结束。
(1 < n <= 1000, 0 < m < 100000, s != t)
```

**输出：**

```
输出一行有两个数：最短距离及其花费。
```

**输入样例：**

```
3 2
1 2 5 6
2 3 4 5
1 3
0 0
```

**输出样例：**

```
9 11
```



**思路：**

```
使用Dijstra，在路程相同时再比较花费。
```



**代码：**

```c++
#include<stdio.h>
#include<vector>
using namespace std;

struct E {		//邻接链表元素结构体
	int next;
	int c;
	int cost;
};

vector<E> edge[1001];	//邻接链表
int Dis[1001];			//距离数组
int cost[1001];			//花费数组
bool mark[1001];		//是否属于集合K数组

int main() {
	int n, m, S, T;
	while (scanf("%d%d", &n, &m) != EOF) {
		if (n == 0 && m == 0) break;
		for (int i = 1; i <= n; i++) edge[i].clear();
		while (m--) {
			int a, b, c, cost;
			scanf("%d%d%d%d", &a, &b, &c, &cost);
			E tmp;
			tmp.c = c;
			tmp.cost = cost;
			tmp.next = b;
			edge[a].push_back(tmp);
			tmp.next = a;
			edge[b].push_back(tmp);
		}
		scanf("%d%d", &S, &T);
		for (int i = 1; i <= n; i++) {
			Dis[i] = -1;
			mark[i] = false;
		}
		Dis[S] = 0;
		mark[S] = true;
		int newP = S;		//以S为起点，将其加入集合K，且其最短距离确定为0

		for (int i = 1; i < n; i++) {
			for (int j = 0; j < edge[newP].size(); j++) {
				int t = edge[newP][j].next;
				int c = edge[newP][j].c;
				int cos = edge[newP][j].cost;
				if (mark[t] == true) continue;
				//距离更小，或距离相同时花费更少，则更新
				if (Dis[t] == -1 || Dis[t] > Dis[newP] + c || Dis[t] == Dis[newP] + c && cost[t] > cost[newP] + cos) {
					Dis[t] = Dis[newP] + c;
					cost[t] = cost[newP] + cos;
				}
			}
			int min = 123123123;
			for (int j = 1; j <= n; j++) {			//选择最小值，这时不用考虑花费的因素，因为在上面已经考虑过了
				if (mark[j] == true) continue;
				if (Dis[j] == -1) continue;
				if (Dis[j] < min) {
					min = Dis[j];
					newP = j;
				}
			}
			mark[newP] = true;
		}
		printf("%d %d\n", Dis[T], cost[T]);
	}
	return 0;
}
```

