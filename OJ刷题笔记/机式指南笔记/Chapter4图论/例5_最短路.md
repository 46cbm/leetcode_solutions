# 例5_最短路

**题目描述：**

```
在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场时，非常累！所以现在他们想寻找最短的从商店到赛场的路线。
```

**输入：**

```
输入包括多组数据。每组数据的第一行是两个整数N、M(N <= 100, M <= 100000)，N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地。M则表示成都有几条路。接下来输入N行，每行包括3个整数A，B，C（1 <= A, B <= N,   1 <= C <= 1000），表示在路口A与路口B之间有一条路线，工作人员需要C分钟的时间来走过这条路。输入保证至少存在1条从商店到赛场的路线。当输入两个为0时，输入结束。
```

**输出：**

```
对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间。
```

**输入样例：**

```
2 1
1 2 3
3 3
1 2 5
2 3 5
3 1 2
0 0
```

**输出样例：**

```
3
2
```



**思路：**

```
使用Floyd算法。N的最大值为100，N^3在接受范围之内。
```



**代码：**

```c++
#include<stdio.h>
int ans[101][101];		//存放图的邻接矩阵

int main() {
	int n, m;
	while (scanf("%d%d", &n, &m) != EOF) {
		if (n == 0 && m == 0) break;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++)
				ans[i][j] = -1;			//邻接矩阵初始化，用-1代表无穷
			ans[i][i] = 0;				//自己到自己为0
		}
		while (m--) {
			int a, b, c;
			scanf("%d%d%d", &a, &b, &c);
			ans[a][b] = ans[b][a] = c;	//无向图，所以赋值两次
		}
		for (int k = 1; k <= n; k++) {
			for (int i = 1; i <= n; i++) {
				for (int j = 1; j <= n; j++) {
					if (ans[i][k] == -1 || ans[k][j] == -1)continue;			//若两个值中有一个是无穷，则ans[i][j]不能由于经过k点而被更新，跳过循环，保持原值
					if (ans[i][j] == -1 || ans[i][k] + ans[k][j] < ans[i][j])	//经过k点的路径更短，则更新该值
						ans[i][j] = ans[i][k] + ans[k][j];
				}
			}
		}
		printf("%d\n", ans[1][n]);
	}
	return 0;
}
```

