# 例5_二叉排序树

**题目描述：**

```
输入一序列整数，建立二叉排序树，并进行前序中序后序遍历。若有重复元素，直接忽略
```

**输入：**

```
输入第一行包括一个整数n(1 <= n <= 100)。接下来的一行包括n的整数。
```

**输出：**

```
可能有多组测试数据，对每组测试数据，建立一个二叉排序树，进行前序中序后序遍历并输出。每组遍历输出占一行。
```

**输入样例：**

```
5
1 6 5 9 8
```

**输出样例：**

```
1 6 5 9 8 
1 5 6 8 9 
5 8 9 6 1
```



**思路：**

```
还是用静态数组来存放树。
```



**代码：**

```c++
#include<stdio.h>
#include<string>
using namespace std;

struct Node {
	Node *lchild;
	Node *rchild;
	int c;
}Tree[110];

int loc;		//静态数组中被使用元素个数

Node *create() {
	Tree[loc].lchild = Tree[loc].rchild = NULL;
	return &Tree[loc++];
}

void PreOrder(Node *T) {
	printf("%d ", T->c);
	if (T->lchild != NULL)
		PreOrder(T->lchild);
	if (T->rchild != NULL)
		PreOrder(T->rchild);
}

void InOrder(Node *T) {
	if (T->lchild)
		InOrder(T->lchild);
	printf("%d ", T->c);
	if (T->rchild)
		InOrder(T->rchild);
}

void PostOrder(Node *T) {
	if (T->lchild)
		PostOrder(T->lchild);
	if (T->rchild)
		PostOrder(T->rchild);
	printf("%d ", T->c);
}

Node *Insert(Node *T, int c) {
	if (T == NULL) {
		T = create();
		T->c = c;
		return T;
	}
	else if (T->c > c) {			//输入元素若有重复，直接忽略
		T->lchild = Insert(T->lchild, c);
	}
	else if (T->c < c) {
		T->rchild = Insert(T->rchild, c);
	}
	return T;
}

int main() {
	int n;
	while (scanf("%d", &n) != EOF) {
		loc = 0;
		int x;
		Node *T = NULL;
		for (int i = 0; i < n; i++) {
			scanf("%d", &x);
			T = Insert(T, x);
		}
		PreOrder(T); printf("\n");
		InOrder(T); printf("\n");
		PostOrder(T);
	}
	return 0;
}
```

