# 例2_简单计算器

**题目描述：**

```
输入一个只包含+-*/的非负整数表达式，计算表达式的值		
```

**输入：**

```
输入包含多个测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。所有的表达式都是合法的表达式。当一行中只有0时输入结束，相应的结果不用输出。
```

**输出：**

```
对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。
```

**输入样例：**

```
1 + 2
4 + 2 * 5 - 7 / 11
0
```

**输出样例：**

```
3.00
13.36
```



**思路：**

```
利用栈求表达式的值：
1）设立两个栈，一个保存运算符，一个保存数字
2）在表达式首位添加标记运算符，该运算符优先级最低
3）从左至右遍历表达式。若便利到运算符，则将其与运算栈顶的运算符比较。若栈为空，或当前运算符优先级严格大于栈顶运算符的优先级，则将该运算符入栈。遍历字符串下一个元素
4）若不满足3的条件，则弹出栈顶运算符，再弹出两个数字，运算后将结果压入数字栈。再用当前运算符和新的栈顶运算符比较
5）若遍历到数字，则直接入数字栈
6）若运算栈中仅有两个运算符，且栈顶运算符为标记运算符，则表达式结束。此时数字栈中的唯一数字即是表达式的值。
```



**代码：**

```c++
#include<stack>
#include<stdio.h>
using namespace std;

char str[200];
//规定首尾标记运算符为0号，加减乘除依次为1234
//优先级矩阵，mat[i][j] = 1，表示表示i运算符优先级大于j运算符
int mat[][5] = {
	1,0,0,0,0,
	1,0,0,0,0,
	1,0,0,0,0,
	1,1,1,0,0,
	1,1,1,0,0,
};

stack<int> op;
stack<double> in;


//获取表达式中的下一个元素
//reto为true，表示该元素为一个运算符，其编号存在retn中
//reto为false，表示该元素为一个数，其值存在retn中，i表示遍历到的字符串的下标
void GetOp(bool &reto, int &retn, int &i) {
	if (i == 0 && op.empty() == true) {		//遍历到字符串的第一个字符，添加我们的标记运算符
		reto = true;
		retn = 0;
		return;
	}
	if (str[i] == 0) {		//字符串遍历结束，同样添加我们的标记运算符
		reto = true;
		retn = 0;
		return;
	}
	if (str[i] >= '0' && str[i] <= '9') {
		reto = false;		//为数字
	}
	else {					//为运算符
		reto = true;
		if (str[i] == '+')
			retn = 1;
		else if (str[i] == '-')
			retn = 2;
		else if (str[i] == '*')
			retn = 3;
		else
			retn = 4;
		i += 2;		//有空格，所以加2
		return;
	}

	//因为数字位数不确定，所以计算数字大小
	retn = 0;
	for (; str[i] != ' ' && str[i] != 0; i++) {
		retn *= 10;
		retn += str[i] - '0';
	}
	if (str[i] == ' ')	//跳过空格
		i++;
	return;
}

int main() {
	while (gets_s(str)) {
		if (str[0] == '0' && str[1] == 0) break;		//只输入了一个0
		bool retop;
		int retnum;
		int idx = 0;

		while (!op.empty()) op.pop();		//清空栈
		while (!in.empty()) in.pop();
		while (true) {
			GetOp(retop, retnum, idx);		//获取下一个元素
			if (retop == false) {
				in.push((double)retnum);	//数字直接入栈
			}
			else {
				double tmp;
				//运算符栈为空或当前运算符严格大于栈顶运算符，则入栈
				if (op.empty() == true || mat[retnum][op.top()] == 1) {
					op.push(retnum);
				}
				else {
					while (mat[retnum][op.top()] == 0) {		//当前运算符优先级小于等于栈顶，则反复计算
						int ret = op.top();
						op.pop();
						double b = in.top();
						in.pop();
						double a = in.top();
						in.pop();

						if (ret == 1) tmp = a + b;
						else if (ret == 2) tmp = a - b;
						else if (ret == 3) tmp = a * b;
						else tmp = a / b;
						in.push(tmp);
					}
					op.push(retnum);
				}
			}
			if (op.size() == 2 && op.top() == 0) break;		//运算符栈只有两个元素，且 栈顶为标记运算符，则结束
		}
		printf("%.2f\n", in.top());
	}
	return 0;
}
```

