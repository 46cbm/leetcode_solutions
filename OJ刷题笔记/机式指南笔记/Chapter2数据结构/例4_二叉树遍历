# 例4_二叉树遍历

**题目描述：**

```
给定一个二叉树的前序和中序遍历，求后序遍历
```

**输入：**

```
两行字符串长度均小于26，结点以大写字母表示。
测试样例多组，每组两行。对于每组测试样例，输出一行后序。
```

**输出：**

```

```

**输入样例：**

```
ABC
BAC
FDXEAG
XDEFAG
```

**输出样例：**

```
BCA
XEDGAF
```



**思路：**

```
先通过先序和中序还原二叉树，再后序遍历即可。
这里还原二叉树时没有动态申请内存空间，而是用一个静态数组来存放树。不熟悉空间的申请和释放，则用这种方法比较稳妥。
```



**代码：**

```c++
#include<stdio.h>
#include<string.h>

struct Node {
	Node *lchild;
	Node *rchild;
	char c;
}Tree[50];			//静态内存分配数组
int loc;			//静态数组中已经分配的结点个数

//申请一个结点空间，返回指向其的指针
Node *create() {
	Tree[loc].lchild = Tree[loc].rchild = NULL;
	return &Tree[loc++];
}

char str1[30], str2[30];	//保存前序和中序字符串

void PostOrder(Node *T) {
	if (T->lchild != NULL)
		PostOrder(T->lchild);
	if (T->rchild != NULL)
		PostOrder(T->rchild);
	printf("%c", T->c);
}

Node *Build(int s1, int e1, int s2, int e2) {
	Node *ret = create();
	ret->c = str1[s1];
	int rootIdx;
	for(int i = s2; i <= e2; i++)
		if (str1[s1] == str2[i]) {
			rootIdx = i; break;
		}
	if (rootIdx != s2)	//左子树不为空
		ret->lchild = Build(s1 + 1, s1 + (rootIdx - s2), s2, rootIdx - 1);
	if (rootIdx != e2)	//右子树不为空
		ret->rchild = Build(s1 + (rootIdx - s2) + 1, e1, rootIdx + 1, e2);
	return ret;
}

int main() {
	while (scanf("%s", str1) != EOF) {
		scanf("%s", str2);
		loc = 0;
		int L1 = strlen(str1);
		int L2 = strlen(str2);
		Node *T = Build(0, L1 - 1, 0, L2 - 1);
		PostOrder(T);
		printf("\n");
	}
	return 0;
}
```

