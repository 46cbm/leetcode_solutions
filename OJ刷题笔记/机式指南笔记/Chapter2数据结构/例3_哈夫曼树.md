# 例3_哈夫曼树

**题目描述：**

```
哈夫曼树，第一行输入一个数n，表示叶节点的个数。需要用这些叶节点生成哈夫曼树。输出生成的哈夫曼树的权值。
```

**输入：**

```
输入有多组数据。
每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100, 2 <= n <= 1000）
```

**输出：**

```
输出权值
```

**输入样例：**

```
5
1 2 2 5 9
```

**输出样例：**

```
37
```



**思路：**

```
priority_queue<Type, Container, Functional>
其中Type 为数据类型，Container为保存数据的容器，Functional 为元素比较方式
Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector。比较方式默认用operator<，所以如果把后面2个参数缺省的话，优先队列就是大顶堆（降序），队头元素最大。
```



**代码：**

```c++
#include<queue>
#include<stdio.h>
#include<functional>	//for greater
using namespace std;

priority_queue<int, vector<int>, greater<int>> Q;	//小顶堆
int main() {
	int n;
	while (scanf("%d", &n) != EOF) {
		while (Q.empty() == false) Q.pop();		//清空堆中的元素
		for (int i = 1; i <= n; i++) {
			int x;
			scanf("%d", &x);
			Q.push(x);
		}
		int ans = 0;
		while (Q.size() > 1) {		//反复取出堆中两个最小的元素
			int a = Q.top();
			Q.pop();
			int b = Q.top();
			Q.pop();
			ans += a + b;
			Q.push(a + b);
		}
		printf("%d\n", ans);
	}
	return 0;
}
```

