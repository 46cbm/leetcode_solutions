# 例2_胜利大逃亡

**题目描述：**

```
Ignatius被魔王抓走了，有一天魔王出差去了。这可是Ignatius逃亡的好机会。魔王住在一个城堡里。城堡是一个A*B*C的立方体，可以被表示成A个B*C的矩阵。刚开始Ignatius被关在（0,0,0）的位置，离开城堡的门在（A-1,B-1,C-1）的位置。现在知道魔王将在T分钟后回到城堡，Ignatius每分钟能从一个坐标走到相邻的六个坐标中的一个。现在给你城堡的地图，请你计算出Ignatius能否在魔王回来之前离开城堡（如果走到出口的时候魔王刚好回来也算逃亡成功），如果可以请输出多少分钟才能离开，如果不能则输出-1.
```

**输入：**

```
输入数据的第一行是一个正整数K，表明有多少组测试。每组测试数据第一行是四个正整数A,B,C,T（1 <= A,B,C <= 50,  1 <= T <= 1000），它们分别代表城堡的大小和魔王回来的时间。然后是A块输入数据（先是第0块，然后是第1块....），每块输入数据有B行，每行C个正整数，代表迷宫的布局。其中0代表路，1代表墙。
```

**输出：**

```
对于每组测试数据，如果Ignatius能够在魔王回来前离开城堡，那么输出它最少需要多少分钟，如果不能，则输出-1
```

**输入样例：**

```
1
3 3 4 20
0 1 1 1 
0 0 1 1 
0 1 1 1
1 1 1 1
1 0 0 1
0 1 1 1
0 0 0 0 
0 1 1 0
0 1 1 0
```

**输出样例：**

```
11
```



**思路：**

```
在状态中进行搜索，一个状态是一个四元组（x,y,z,t）t是从0,0,0走到x,y,z所用的时间。
对已经搜索过的状态用makr进行标记。
```



**代码：**

```c++
#include<stdio.h>
#include<queue>
using namespace std;

bool mark[50][50][50];
int maze[50][50][50];
struct N {
	int x, y, z;
	int t;
};

queue<N> Q;
int go[][3] = {		//坐标变换数组
	1,0,0,
	-1,0,0,
	0,1,0,
	0,-1,0,
	0,0,1,
	0,0,-1
};

int BFS(int a, int b, int c) {
	while (Q.empty() == false) {
		N now = Q.front();
		Q.pop();
		for (int i = 0; i < 6; i++) {
			int nx = now.x + go[i][0];
			int ny = now.y + go[i][1];
			int nz = now.z + go[i][2];
			
			if (nx < 0 || nx >= a || ny < 0 || ny >= b || nz < 0 || nz >= c) continue;//在立方体之外，则跳过
			if (maze[nx][ny][nz] == 1) continue;		//是墙,跳过
			if (mark[nx][ny][nz] == true) continue;		//状态已经被得到过，跳过

			N tmp;		//新的状态
			tmp.x = nx;
			tmp.y = ny;
			tmp.z = nz;
			tmp.t = now.t + 1;
			Q.push(tmp);
			mark[nx][ny][nz] = true;	//标记该状态
			if (nx == a - 1 && ny == b - 1 && nz == c - 1)
				return tmp.t;			//走到终点，返回
		}
	}
	return -1;
}

int main() {
	int K;
	scanf("%d", &K);
	while (K--) {
		int a, b, c, t;
		scanf("%d%d%d%d", &a, &b, &c, &t);
		for (int i = 0; i < a; i++) {
			for (int j = 0; j < b; j++) {
				for (int k = 0; k < c; k++) {
					scanf("%d", &maze[i][j][k]);
					mark[i][j][k] = false;
				}
			}
		}
		while (Q.empty() == false) Q.pop();
		mark[0][0][0] = true;		//起点标记
		N tmp;
		tmp.t = tmp.x = tmp.y = tmp.z = 0;
		Q.push(tmp);
		int res = BFS(a, b, c);
		if (res <= t)
			printf("%d\n", res);
		else
			printf("-1\n", res);
	}
	return 0;
}
```

