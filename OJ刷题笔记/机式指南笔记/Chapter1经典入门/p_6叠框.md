# 例6_叠框

**题目描述：**

```
把一个个大小差一圈的框叠上去，使得从上往下看时，边框花色交错。
```

**输入：**

```
每组数据输入是一个三元组，分别是外框尺寸n （0<n<80），中心的字符，外框的字符。
```

**输出：**

```
输出叠在一起的框图案。中心花色与外框花色从内起交错相叠。
最外层的框角被打磨掉。
```

**输入样例：**

```
5 B A
5 @ W
```

**输出样例：**

```
 BBB 
BAAAB
BABAB
BAAAB
 BBB

 @@@
@WWW@
@W@W@
@WWW@
 @@@
```



**思路：**

```
叠框同一般从上至下，从左至右的输出顺序不同。故先排版，后输出。
用一个数组来缓存排版。规定阵列左上方坐标为（1,1），右下角坐标为（n,n）
最中间的字符坐标为（n/2+1, n/2+1），次圈左上角坐标为(n/2+1-1, n/2+1-1)
此外，中心圈长度为1，次中心圈长度为3，按2递增。
```



**代码：**

```c++
#include<iostream>
using namespace std;

int main() {
	int outPutBuf[82][82];		//缓存排版
	char a, b;					
	int n;
	bool firstCase = true;		//是否是第一组数据，在第一组数据之后的每组数据之前都要输出一个换行
	while (scanf("%d %c %c", &n, &a, &b) == 3) {
		if (firstCase == true)
			firstCase = false;
		else
			printf("\n");

		for (int i = 1, j = 1; i <= n; i += 2, j++) {	//i为当前框的边长
			int x = n / 2 + 1, y;
			x -= j - 1;
			y = x;							//确定右上角的坐标x，y
			char c = j % 2 == 1 ? a : b;	//由内向外奇圈为a，偶圈为b
			for (int k = 1; k <= i; k++) {
				outPutBuf[x + k - 1][y] = c;			//左
				outPutBuf[x + k - 1][y + i - 1] = c;	//右
				outPutBuf[x][y + k - 1] = c;			//上
				outPutBuf[x + i - 1][y + k - 1] = c;	//下
			}
		}
		if (n != 1) {			//只有一个字符时不用此步骤
			outPutBuf[1][1] = ' ';
			outPutBuf[1][n] = ' ';
			outPutBuf[n][1] = ' ';
			outPutBuf[n][n] = ' ';
		}
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++)
				printf("%c", outPutBuf[i][j]);
			printf("\n");
		}
	}
	return 0;
}
```

