# 例8_看最多的电视节目

**题目描述：**

```
给出节目的开始和结束时间，求最多能看多少个节目
```

**输入：**

```
输入数据包含多组实例，每个实例开头是一行整数n(n <= 100)，表示你喜欢的节目总数，然后是n行数据
每行包括两个数据，第i个节目的开始和结束时间(1 <= i <= n)。每个时间都用整数表示。
n = 0表示结束
```

**输出：**

```
对每个测试实例，输出能完整看到的节目的个数，每个测试实例的输出占一行。
```

**输入样例：**

```
12
1 3
3 4
0 7
3 8
15 19
15 20
10 15
8 18
6 12
5 10
4 14
2 9
0
```

**输出样例：**

```
5
```



**思路：**

```
贪心算法思路虽然简单，但是贪心策略的选择比较麻烦。
本题选择结束时间最早的节目可以得到最优解。
```



**代码：**

```c++
#include<iostream>
#include<algorithm>
using namespace std;

struct goods {
	double j;		//总重量
	double f;		//总价格
	double s;		//性价比 即重量价格比
	bool operator <(const goods &A) const {		//性价比按降序排列
		return s > A.s;
	}
}buf[1000];

int main() {
	double m;
	int n;
	while (scanf("%lf %d", &m, &n) != EOF) {
		if (m == -1 && n == -1)break;
		for (int i = 0; i < n; i++) {
			scanf("%lf %lf", &buf[i].j, &buf[i].f);
			buf[i].s = buf[i].j / buf[i].f;
		}
		sort(buf, buf + n);
		int idx = 0;
		double sum = 0;
		while (m > 0 && idx < n) {
			if (m > buf[idx].f) {		//可以全部买下
				sum += buf[idx].j;
				m -= buf[idx].f;
			}
			else {
				sum += buf[idx].s * m;	//钱不够，只能买部分
				m = 0;
			}
			idx++;
		}
		printf("%.3lf\n", sum);
	}
	return 0;
}
```

