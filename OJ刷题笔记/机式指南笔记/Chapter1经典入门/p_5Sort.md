# 例5_Sort

**题目描述：**

```
给定n个整数，请按从大到小的顺序输出前m大的数。
```

**输入：**

```
每组测试数据有两行，第一行有两个数n，m（0 < n,m <1000000），第二行包含n个各不相同，
且都处于[-500000, 500000]的整数
```

**输出：**

```
对每组测试数据从大到小的顺序输出前m大的数。
```

**输入样例：**

```
5 3
3 -35 92 213 -644
```

**输出样例：**

```
213 92 3
```



**思路：**

```
利用Hash的思想，即将存储位置与数据本身对应起来。
本题待排数据巨大，即是O(nlongn)的快排也可能会超时。
输入的数据在[-500000,500000]之间，我们再加一个偏移量，将其映射到数组下标[0,1000000]中。

本题各组数据中的值都是不同的，若有相同，则用数组记录重复次数即可。
```



**代码：**

```c++
#include<iostream>
#define OFFSET 500000	//偏移量
int Hash[1000001];		//记录是否在给定的数据中出现，注意数据的范围中共有100001个数。

int main() {
	int n, m;
	while (scanf("%d %d", &n, &m) != EOF) {
		for (int i = -500000; i <= 500000; i++)
			Hash[i + OFFSET] = 0;
		int x;
		for (int i = 0; i < n; i++) {
			scanf("%d", &x);
			Hash[x + OFFSET] = 1;
		}
		for (int i = 500000; i >= -500000; i--) {
			if (Hash[i + OFFSET] == 1) {
				printf("%d", i);
				m--;
				if (m != 0)			//最后一个数后面没有空格
					printf(" ");
				else {
					printf("\n");
					break;
				}
			}
		}
	}
	return 0;
}
```

