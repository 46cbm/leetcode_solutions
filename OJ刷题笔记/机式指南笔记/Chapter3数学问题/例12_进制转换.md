# 例12_进制转换

**题目描述：**

```
将M进制的数X转换为N进制输出。输入时字母部分为大写，输出是为小写。有大数据。
```

**输入：**

```
第一行输入两个整数M、N（2 <= M,N <= 36）
下面的一行输入M进制的数X
```

**输出：**

```
输出X的N进制表示的数。
```

**输入样例：**

```
16 10
F
```

**输出样例：**

```
15
```



**思路：**

```
明确告知有大数据，应该用高精度整数。考虑到进制转换的内容，高精度整数需要进行如下运算：高精度整数与普通整数的求积、高精度整数之间求和、高精度整数除以普通整数、高精度整数对普通整数求模等。
```



**代码：**

```c++
#include<stdio.h>
#include<string.h>
#define maxDigits 50

struct bigInteger{
	int digit[maxDigits];
	int size;
	
	void Init(){
		for(int i = 0; i < maxDigits; i++) digit[i] = 0;
		size = 0;
	}
	
	//用一个普通整数初始化高精度整数 
	void Set(int x){
		Init();
		do{
			digit[size++] = x % 10000;
			x /= 10000;
		}while(x != 0);
	}
	
	void Output(){
		for(int i = size-1; i >= 0; i--){
			if(i != size-1) printf("%04d", digit[i]);
			else printf("%d", digit[i]);
		}
		printf("\n");
	}
	
	bigInteger operator * (int x) const{
		bigInteger res;
		res.Init();	
		int carry = 0;
		for(int i = 0; i < size; i++){
			int tmp = x * digit[i] + carry;
			carry = tmp / 10000;
			tmp %= 10000;
			res.digit[res.size++] = tmp;
		}
		if(carry != 0)
			res.digit[res.size++] = carry;
		return res;
	}
	
	bigInteger operator + (const bigInteger &A) const{
		bigInteger res;
		res.Init();
		int carry = 0;
		for(int i = 0; i < A.size || i < size; i++){
			int tmp = A.digit[i] + digit[i] + carry;
			carry = tmp / 10000;
			tmp %= 10000;
			res.digit[res.size++] = tmp;
		}
		if(carry != 0)
			res.digit[res.size++] = carry;
		return res;
	}
	
	bigInteger operator / (int x) const{
		bigInteger res;
		res.Init();
		int remainder = 0;
		for(int i = size-1; i >= 0; i--){				//从高位到低位完成除法 
			int t = (remainder*10000+digit[i]) / x;		//当前位数值加上高位剩余余数的和对x求商
			int r = (remainder*10000+digit[i]) % x;		//当前位数值加上高位剩余余数的和对x求模
			res.digit[i] = t;
			remainder = r; 
		}
		res.size = 0;
		for(int i = 0; i < maxDigits; i++)		//确定size取值 
			if(digit[i] != 0) res.size = i;
		res.size++;		//注意size比在我们使用过的最高为的+1位置
		return res; 
	}
	
	int operator % (int x) const{
		int remainder = 0;
		for(int i = size-1; i >= 0; i--){
			int t = (remainder * 10000 + digit[i]) / x;
			int r = (remainder * 10000 + digit[i]) % x;
			remainder = r;
		}
		return remainder;
	}
}a, b, c; 

char str[10000];
char ans[10000];

int main(){
	int n, m;
	while(scanf("%d%d", &m, &n) != EOF){
		scanf("%s", str);
		int len = strlen(str);
		a.Set(0);		//a保存转换成十进制的m进制数 
		b.Set(1);		//b依次代表每一位的权重 
		
		//由低位至高位转换m进制数至相应的十进制数
		for(int i = len-1; i >= 0; i--){
			int t;
			if(str[i] >= '0' && str[i] <= '9')
				t = str[i] - '0';
			else
				t = str[i] - 'A' + 10;
			a = a + b * t;
			b = b * m;
		} 
		int size = 0;
		do{
			int t = a % n;
			if(t >= 10) ans[size++] = t - 10 + 'a';
			else ans[size++] = t + '0';
			a = a/n;
		}while(a.digit[0] != 0 || a.size != 1);
		for(int i = size-1; i >= 0; i--) printf("%c", ans[i]);
		printf("\n");
	}
	return 0;
}  
```

