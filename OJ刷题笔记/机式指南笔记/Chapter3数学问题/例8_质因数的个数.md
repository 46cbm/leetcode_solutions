# 例8_质因数的个数

**题目描述：**

```
求正整数N(N>1)的质因数的个数。
相同的质因数要重复计算，如120=2*2*2*3*5，共有5个质因数。若N为质数，则N为N的质因数
```

**输入：**

```
可能有多组测试数据，一组一行 （1 < N < 10^9）
```

**输出：**

```

```

**输入样例：**

```
120
```

**输出样例：**

```
5
```



**思路：**

```
用例7的方法先筛出范围内的所有素数。依次遍历所有小于n的素数，判断其是否为n的因数。若确定某素数为n的因数，则通过试除确定其对应的幂指数。
```



**代码：**

```c++
#include<stdio.h>

bool mark[100001] = {false};  //都初始化为没标记
int prime[100001];
int primeSize;

//素数筛法，和例7一样
void Init() {			
	primeSize = 0;
	for (int i = 2; i <= 10000; i++) {
		if (mark[i] == true) continue;	//已经标记，不是素数，跳过
		prime[primeSize++] = i;
		for (int j = i * i; j <= 10000; j += i)	//i是素数，则i的倍数均不是素数
			mark[j] = true;
	}
}

int main() {
	Init();
	int n;
	while (scanf("%d", &n) != EOF) {
		int ansPrime[30];		//按顺序存放分解出的质因数
		int ansSize = 0;
		int ansNum[30];			//保存分解出的质因数对应的幂指数
		for (int i = 0; i < primeSize; i++) {		//依次测试每一个素数
			if (n % prime[i] == 0) {				//若该素数能整除被分解数
				ansPrime[ansSize] = prime[i];
				ansNum[ansSize] = 0;				//幂指数初始化为0，然后反复除，计算出幂指数
				while (n % prime[i] == 0) {
					ansNum[ansSize]++;
					n /= prime[i];
				}
				ansSize++;
				if (n == 1) break;					//若已经被分解成1，则提前结束
			}
		}
		if (n != 1) {		//若测试了2-100000内所有质数，n仍然未被分解成1，则剩余的因数一定是一个大于100000的素因数
			ansPrime[ansSize] = n;
			ansNum[ansSize++] = 1;
		}
		int ans = 0;
		for (int i = 0; i < ansSize; i++)			//求幂指数的和
			ans += ansNum[i];
		printf("%d\n", ans);
	}
	return 0;
}
```

