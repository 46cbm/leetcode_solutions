# 例10_a+b

**题目描述：**

```
实现一个加法器，使其能够输出a+b的值
```

**输入：**

```
两个数a、b，位数不超过1000位
```

**输出：**

```
可能有多组测试数据，对每组测试数据，输出a+b的值
```

**输入样例：**

```
2 6
1000000000000 10000000000000000
```

**输出样例：**

```
8
10001000000000000
```



**思路：**

```
显然内置类型是不够用的
c\c++中，通常用一个结构体来保存高精度整数
struct bigInteger{
    int digit[1000];
    int size;
};
这里以每4位为一个保存单位，如12346789保存为：digit[0] = 6789; digit[1] = 2345; digit[0] = 1; size = 3
```



**代码：**

```c++
#include<stdio.h>
#include<string.h>

struct bigInteger{
	int digit[1000];
	int size;
	
	void Init(){
		for(int i = 0; i < 1000; i++) digit[i] = 0;
		size = 0;
	}
	
	//从字符串中提取整数 
	void Set(char str[]){	
		Init();
		int len = strlen(str);
		//从最后一个字符开始倒序遍历字符串，j控制每4个字符转换为一个数字存入数组，c表示权重，1,10,100,1000变化 
		for(int i = len-1, j = 0, t = 0, c = 1; i >= 0; i--){
			t += (str[i]-'0') *c;
			j++;
			c *= 10;
			if(j == 4 || i == 0){		//已经连续转换4个字符，或已经到达最后一个字符 
				digit[size++] = t;
				j = 0; t = 0; c = 1;
			}
		}
	}
	
	//将该整数输出 
	void Output(){		
		for(int i = size - 1; i >= 0; i--){
			if(i != size - 1) printf("%04d", digit[i]);		//不是最后一位数字，要用0补足到4位 
			else printf("%d", digit[i]);
		}
		printf("\n");
	}
	
	//重载加法 
	bigInteger operator + (const bigInteger &A) const{
		bigInteger res;
		res.Init();
		int carry = 0;		//进位
		for(int i = 0; i < A.size || i < size; i++){
			int tmp = A.digit[i] + digit[i] + carry;
			carry = tmp / 10000;	//计算进位
			tmp %= 10000;			//丢掉进位，取最后四位
			res.digit[res.size++] = tmp; 
		} 
		if(carry != 0){		//若最后加完还有进位 
			res.digit[res.size++] = carry;
		}
		return res;
	}
}a, b, c;

char str1[1002], str2[1002];
int main(){
	while(scanf("%s%s", str1, str2) != EOF){
		a.Set(str1);
		b.Set(str2);
		c = a + b;
		c.Output();
	}
	return 0;
}
```

