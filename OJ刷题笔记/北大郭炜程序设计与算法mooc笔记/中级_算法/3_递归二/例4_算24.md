**题目描述：**

```   
给出4个小于10的正整数，你可以用加减乘除4中运算以及括号把这4个数连接起来得到一个表达式。
问是否存在一种方式，使得表达式的值等于24.
这里是除法是实数除法。
如对5,5,5,1  5*(5-1/5) = 24
1,1,4,2   则得不到24
```

**输入：**

```
输入数据包括多行，每一行给出一组测试数据，包括4个小于10的正整数。
最后一个测试数据为4个0，表示输入结束。
```

**输出：**

```
对于每一组测试数据，输出一行，如果可以得到24，输出“YES”，否则输出“NO”
```

**输入样例：**

```
5 5 5 1
1 1 4 2 
```

**输出样例：**

```
YES
NO
```



**思路：**

```
n个数中先算两个数，用这个结果再和n-2个数求24，变成了n-1个数求24的问题
边界条件：只有一个数，且等于24
（注意浮点数不能用==，用差）
```



**代码：**

```c++
#include<iostream>
#include<cmath>
using namespace std;

double a[5];
#define EPS 1e-6

bool isZero(double x) {
	return fabs(x) <= EPS;
}

bool count24(double a[], int n) {
	if (n == 1) {
		if (isZero(a[0] - 24))
			return true;
		else
			return false;
	}
	double b[5];
	for(int i = 0; i < n-1; i++)
		for (int j = i + 1; j < n; j++) {		//枚举两个数的组合
			int m = 0;
			for (int k = 0; k < n; k++)			//把除两个数外剩下的数放入b中
				if (k != i && k != j)
					b[m++] = a[k];
			//对选出来的两个数加减乘除依次枚举
			b[m] = a[i] + a[j];
			if (count24(b, m + 1))
				return true;
			b[m] = a[i] - a[j];
			if (count24(b, m + 1))
				return true;
			b[m] = a[j] - a[i];
			if (count24(b, m + 1))
				return true;
			b[m] = a[i] * a[j];
			if (count24(b, m + 1))
				return true;
			if (!isZero(a[j])) {
				b[m] = a[i] / a[j];
				if (count24(b, m + 1))
					return true;
			}
			if (!isZero(a[i])) {
				b[m] = a[j] / a[i];
				if (count24(b, m + 1))
					return true;
			}
		}
	return false;
}

int main() {
	while (cin >> a[0] >> a[1] >> a[2] >> a[3]) {
		if (a[0] == a[1] == a[2] == a[3])
			break;
		if (count24(a, 4))
			cout << "YES" << endl;
		else
			cout << "NO" << endl;
	}
	return 0;
}
```

