递归到动态规划的一般转化方法

- 递归函数有n个参数，就定义一个n维数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始，逐步填充数组，相当于计算递归函数值的逆过程。



DP解题的一般思路

1 将原问题分解为子问题

- 把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决（如例1的三角形）。
- 子问题的解一旦求出来就会被保存，所以每个子问题只需要求解一次。

2 确定状态

- DP解题时，我们往往将子问题相关的各个变量的一组取值，称之为一个“状态”。一个“状态”对应于一个或多个子问题。所谓某个状态下的值，就是这个状态所对应的子问题的解。
- 例1中，行号和列号就是一个状态，共有n（n+1）/ 2 个状态。
- 整个问题的复杂度就是状态数目乘以计算每个状态所需要的时间。
- 一般用K维数组来存放K个整型变量构成的状态。一个状态下的值通常会是一个或多个子问题的解。

3 确定一些初始状态（边界状态）的值

- 例1中的初始状态就是底边。

4 确定状态转移方程（已知推未知）

- 状态转移方程可以用一个递推公式来表示，如例1中的

  if(r == N)
  	MaxSum(r, j) = D(r,j);
  else
  	MaxSum(r, j) = Max{MaxSum(r+1, j), MaxSum(r+1, j+1)} + D(r, j);





能用DP解决的问题的特点：

1. 问题具有最优子结构性质。如果问题的最优解所包含的子问题的解也是最有的，我们就称该问题具有最优子结构性质。
2. 无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关。和之前是采用哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。

（不满足无后效性实际上就写不出递推式）



DP常用的两种形式：

1. 递归型

   优点：直观，容易编写

   缺点：层数太深可能爆栈，函数调用带来额外的时间开销。无法使用滚动数组节省空间。总体来说，比递推慢

2. 递推型

   效率高，有可能使用滚动数组节省空间