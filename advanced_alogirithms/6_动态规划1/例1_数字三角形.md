**题目描述：**

```   
    7
   3 8
  8 1 0
 2 7 4 4
4 5 2 6 5

在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或右下走。只需要求出这个最大的和即可，不必给出具体的路径。
三角形的行数大于1小于等于100，数字为0-99
```

**输入：**

```
第一行输入的是行数
```

**输出：**

```

```

**输入样例：**

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

**输出样例：**

```
30
```



**思路：**

```
方法一：用递归

用二维数组存放数字三角形。

D(r,j)：第r行第j个数字（都从1开始）
MaxSum(r,j)：从D(r,j)到底边的各条路径中，最佳路径的数字之和。

问题即是求MaxSum(1,1)

典型的递归问题。
D(r,j)出发，下一步只能走D(r+1, j)或者D(r+1, j+1)。故对N行的三角形：
if(r == N)
	MaxSum(r, j) = D(r,j);
else
	MaxSum(r, j) = Max{MaxSum(r+1, j), MaxSum(r+1, j+1)} + D(r, j);
	
用递归会有大量的重复计算，时间会超过。
除了左右两条边上的，中间和底部的数字每个都会被左上方和右上方的调用。
时间复杂度是2^n


方法二：动态规划
每算出一个MaxSum就保存下来，共n(n+1)/2个数字，复杂度是n^2

方法三：用递推动态规划
最后一层先确定，然后一层一层往上推。

方法四：方法三的空间优化
直接用D的最后一行来实现maxSum的功能。因为D的最后一行后面不会再用到，所以可以覆盖。
```



**代码：**

```c++
//递归版本，OJ会超时
#include<iostream>
#include<algorithm>
#define MAX 101
using namespace std;

int D[MAX][MAX];
int n;

int MaxSum(int i, int j) {
	if (i == n)
		return D[i][j];
	int x = MaxSum(i + 1, j);
	int y = MaxSum(i + 1, j + 1);
	return max(x, y) + D[i][j];
}

int main() {
	int i, j;
	cin >> n;
	for (i = 1; i <= n; i++)
		for (j = 1; j <= i; j++)
			cin >> D[i][j];
	cout << MaxSum(1, 1) << endl;
}


//记忆递归型的DP
#include<iostream>
#include<algorithm>
#define MAX 101
using namespace std;

int D[MAX][MAX];
int n;
int maxSum[MAX][MAX];

int MaxSum(int i, int j) {
	if (maxSum[i][j] != -1)		//不为-1，说明已经算过了
		return maxSum[i][j];
	if (i == n)
		return D[i][j];
	int x = MaxSum(i + 1, j);
	int y = MaxSum(i + 1, j + 1);
	return max(x, y) + D[i][j];
}

int main() {
	int i, j;
	cin >> n;
	for (i = 1; i <= n; i++)
		for (j = 1; j <= i; j++) {
			cin >> D[i][j];
			maxSum[i][j] = -1;	//初始化为-1
		}
	cout << MaxSum(1, 1) << endl;
}

//方法三：递推
#include<iostream>
#include<algorithm>
using namespace std;

#define MAX 101

int D[MAX][MAX]; int n;
int maxSum[MAX][MAX];

int main() {
	int i, j;
	cin >> n;
	for (i = 1; i <= n; i++)
		for (j = 1; j <= i; j++)
			cin >> D[i][j];
	for (int i = 1; i <= n; i++)
		maxSum[n][i] = D[n][i];		//最后一行先确定，然后再往上回推
	for (int i = n - 1; i >= 1; i--)
		for (int j = 1; j <= i; j++)
			maxSum[i][j] = max(maxSum[i + 1][j], maxSum[i + 1][j + 1]) + D[i][j];
	cout << maxSum[1][1] << endl;
}

//空间优化
#include<iostream>
#include<algorithm>
using namespace std;

#define MAX 101

int D[MAX][MAX]; int n;
int *maxSum;

int main() {
	int i, j;
	cin >> n;
	for (i = 1; i <= n; i++)
		for (j = 1; j <= i; j++)
			cin >> D[i][j];
	maxSum = D[n];		//指向D的最后一行
	for (int i = n - 1; i >= 1; i--)
		for (int j = 1; j <= i; j++)
			maxSum[j] = max(maxSum[j], maxSum[j + 1]) + D[i][j];
	cout << maxSum[1] << endl;
}
```

