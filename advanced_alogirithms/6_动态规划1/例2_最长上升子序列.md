**题目描述：**

```   
如给定序列(1,7,3,5,9,4,8)
上升子序列有(1,7)、(3,4,8)，最长上升子序列为(1,3,5,8)
```

**输入：**

```
输入第一行是序列的长度N(1 <= 1000)。第二行给N的整数，这些数的取值范围都在0到10000。
```

**输出：**

```
最长上升自序列的长度
```

**输入样例：**

```
7
1 7 3 5 9 4 8
```

**输出样例：**

```
4
```



**思路：**

```
1）找子问题
“求序列的前n个元素的最长上升子序列的长度”。这是个子问题，但是不具有“无后效性”
如n = 2，则序列为(1,7)，但最后答案不是

“求以ak(k = 1,2,3...N)为终点的最长上升子序列的长度”
一个上升子序列中最右边的那个数，称为该子序列的终点。这个子问题和原问题形式上并不一样，这其实是N个子问题，这N个子问题中，最大的那个就是整个问题的解。

2）确定状态
子问题之和一个变量--数字的位置相关。因此序列中数的位置k就是“状态”，而状态k对应的值，就是ak作为终点的最长上升子序列的长度。
状态一共有N个。

3）找出状态转移方程
maxLen(k)表示以ak作为终点的最长上升子序列的长度，那么：
	maxLen(1) = 1
	maxLen(k) = max{maxLen(i): i <= i < k && ai < ak && k != 1} + 1
				若找不到这样的i，则maxLen(k) = 1
```



**代码：**

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;

const int MAXN = 1010;
int a[MAXN]; int maxLen[MAXN];

int main() {
	int N; cin >> N;
	for (int i = 1; i <= N; i++) {
		cin >> a[i];
		maxLen[i] = 1;
	}
	for (int i = 2; i <= N; i++) {
		for (int j = 1; j < i; j++)
			if (a[i] > a[j])
				maxLen[i] = max(maxLen[i], maxLen[j] + 1);
	}
	cout << *max_element(maxLen + 1, maxLen + N + 1);
	return 0;
}
```

