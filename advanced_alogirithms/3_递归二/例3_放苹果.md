**题目描述：**

```
把M个同样的苹果放在N个同样的盘子里，允许有盘子空着不放。
问有多少种不同的分法。
若有7个苹果，3个盘子，5,1,1和1,5,1是同一种分法。
```

**输入：**

```
第一行输入测试数据的数目t(0 <= t <= 20)。
以下每行均包含两个正整数m和n，以空格分开。1 <= m, n <= 10
```

**输出：**

```
对输入的每组数据m和n，用一行输出相应的k
```

**输入样例：**

```
1
7 3
```

**输出样例：**

```
8
```



**思路：**

```
设i个苹果放在k个盘子里的放法总数是f(i,k)，则：
k > i时，f(i,k) = f(i,i)
k <= i 时， 总放法 = 有盘子为空的放法 + 没盘子为空的放法

有盘子为空的放法：至少有一个盘子为空，把那个空盘子拿走，放法总数不变；
没盘子为空的放法：现在每个盘子里放一个苹果，还剩i-k，放法数就是把i-k个苹果放在k个盘子里。
f(i,k) = f(i, k-1) + f(i-k, k)

边界条件：
m苹果为0时，1种方法。
苹果不为0，0个盘子，没有盘子，没有方法，返回0。
```



**代码：**

```c++
#include<iostream>
using namespace std;

int f(int m, int n) {
	if (n > m)
		return f(m, m);
	if (m == 0)
		return 1;
	if (n == 0)
		return 0;
	return f(m, n - 1) + f(m - n, n);		//这里必然m大于等于n，n则是每次减1，两个参数都是大于等于0的
}

int main() {
	int t, m, n;
	cin >> t;
	while (t--) {
		cin >> m >> n;
		cout << f(m, n) << endl;
	}
	return 0;
}
```

