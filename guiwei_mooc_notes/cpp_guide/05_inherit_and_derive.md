# 继承和派生

## 继承和派生的基本概念

派生类拥有基类的全部成员函数和成员变量，不论是`private`、`protected`、`public`。在派生类的各个成员函数中，不能访问基类中的`private`成员。

派生类对象的内存空间：

- 派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。在派生类对象中，包含着基类对象，且派生类包含的基类对象的存储位置位于派生类对象新增的成员变量之前。

## 继承关系和复合关系

继承：”是“关系。A派生出B，逻辑上要求：一个B对象也是A对象。

复合：”有“关系。C中有成员变量d，d是D的对象。逻辑上要求：D对象是C对象的固有属性或组成部分。

> 在定义复合关系时，切勿出现循环定义。

一个例子：一个主人可以有10条狗。

- 这不能直接定义为复合关系，因为狗并不是人的固有属性或组成部分。正确的写法应是使用指针，让人和狗知道彼此。

```cpp
class CMaster;

class CDog{
    CMaster *pm;
}

class CMaster{
    CDog *dogs[10];
}
```

## 派生类覆盖基类成员

覆盖后，如果在派生类中要访问基类的同名成员，要使用符号作用域`基类名::`

> 一般来说，基类和派生类中不定义同名的成员变量。

## 保护成员

基类的`private`成员：可以被以下函数访问

- 基类的成员函数
- 基类的友员函数

基类的`public`成员：可以被以下函数访问

- 基类的成员函数
- 基类的友员函数
- 派生类的成员函数
- 派生类的友员函数
- 其他函数

基类的`protected`成员：可以被以下函数访问

- 基类的成员函数
- 基类的友员函数
- 派生类的成员函数可以访问当前对象的基类的保护成员

## 派生类的构造函数

- 在创建派生类对象时，需要调用基类的构造函数。在执行一个派生类的构造函数之前，总是先执行基类的构造函数。

调用基类构造函数的两种方式：

- 显示方式：在派生类的构造函数中，为基类的构造函数提供参数（在初始化列表中）
- 隐式方式：在派生类的构造函数中，省略基类的构造函数，派生类的构造函数自动调用基类的默认无参构造函数。

> 析构函数的调用顺序和构造函数相反：派生类自己的析构函数执行完后，再自动调用基类的析构函数。

```cpp
class Bug{
private:
    int nLegs;
    int nColor;

public:
    int nType;
    Bug(int legs, int color);
    void PrintBug(){};
};

Bug::Bug(int legs, int color){
    nLegs = legs;
    nColor = color;
}

class FlyBug: public Bug{
    int nWings;

public:
    FlyBug(int legs, int color, int wings);
};

// 派生类对象初始化基类对象:写在初始化列表中
FlyBug::FlyBug(int legs, int color, int wings):Bug(legs, color){
    nWings = wings;
}
```

封闭派生类对象的构造函数的执行顺序：

1. 先执行基类的构造函数，用以初始化派生类对象中从基类继承的成员
2. 再执行成员对象类的构造函数，用以初始化派生类对象中的成员对象
3. 最后执行派生类自己的构造函数

- 派生类消亡时，析构函数执行的顺序和构造函数相反。

## 公有继承的赋值兼容规则

```cpp
class base{};
class derived: public base{};
base b;
derived d;
```

1. 派生类对象可以赋值给基类对象

```cpp
b = d;  // 因为d中是包含一个b对象的，所以这里就是把那个包含的对象赋值给b
```

2. 派生类对象可以初始化基类引用

```cpp
base &br = d;
```

3. 派生类对象的地址可以赋值给基类的指针

```cpp
base *bp = &d;
```

如果派生方式不是`public`，则上述三条不成立。

## 直接基类和间接基类

- 在声明派生类时，只需要列出它的直接基类。派生类沿着类的层次自动向上继承他的间接基类成员。